# SP4E: Homework 3

C++: Particles Codebase

## Table of Contents

- [Usage](#usage)
- [Output](#output)


## Installation

```
# Clone the repository
git clone https://github.com/meghshukla/SP4E.git

# Navigate to the project directory
cd SP4E/homework3/heat-fft-solver
```

This code requires googletest installed, a popular C++ testing framework. We recommend following the instructions in https://www.jetbrains.com/help/objc/creating-google-test-run-debug-configuration-for-test.html 

While the CMAKELists.txt file can be used to build the executable, it is highly recommended to keep the default settings in it. For instance, FFTW is highly recommended. Instructions included creating a ```build``` directory, running ``` cmake ../ ; make ```

## Usage

The following command ```./particles 5000 500 dummy.csv material_point 0.1 sine``` provides a sample way of running the executable. 5000 is the number of iterations, 500 is the frequency at which to print the intermediate temperature field, ```dummy.csv``` is a dummy file created to run the code for material_point. Since we are not adding any materials, ```circle_orbit.csv```is incompatible with the existing code. Hence, we create a dummy file consisting of ```0 0 0 0``` such that the code execution does not stop. We do not read or use this file in any manner. We choose ```material_point``` as suggested. 0.1 corresponds to the timestep and scales the gradient update. Finally, we add a new argument ```heat source``` which can be one of ```none, sine``` to simulate different heat sources.


## Exercise 1

We follow Doxyfile and its generated html files to explain the Particles codebase. Generally, the code is divided into the following Parent classes:
1. Compute
1. CsvReader/Writer
1. FFT
1. Matrix
1. ParticlesFactoryInterface
1. System
1. SystemEvolution

Multiple classes inherit from these base classes. For instance, ComputeBoundary, ComputeInteraction etc. are inherited from Compute. Different particles such as Planet, PingPoing, MaterialPoint inherit from the ParticlesFactorInterface. The code follows a Singleton design. Atmost one object can be created which inherits from ParticlesFactoryInterface. This is done by checking if the factory point is a ```nullptr``` or not. Matrix consists of various functions used to manipulate the data within matrices. FFT acts as an interface between FFTW and the Particles codebase. SystemEvolution uses System and is the heart of the code. SystemEvolution simulates the stochastic process which is numerically approximated in the method ```evolve```. 

We modify the code to accept a new argument (heat_source), complete the compute_temperature function, fill fft.hh, modify the indexing of data for all matrices (changes in matrix.hh). We additionally use SystemEvolution code to pass multiple variables to System. This is because Compute::compute accepts only *System pointers, thereby all the variables needed to compute the temperature have to be contained within System. This required adding new declarations in the System class and new methods to pass these variables from SystemEvolution to System.

## Note on Exercise 2 and 3
Here is the build process to be followed:
mkdir build 
cd build
cmake -DUSE_FFTW=ON ..
make

In order to create the functionality for the forward and backward transform functions for the Matrix class, and the computation of the frequencies, we will implement functions inside the fft.hh file. We define these functions directly in the header since the file uses inline functions.

The testing for these functions are implemented in test_fft.cc.  For the test of “computeFrequencies", the reference frequencies are generated by the python script called “generate_reference_frequencies.py”, which saves its results into “frequencies_reference.txt”. These results are then used in test_fft.cc.

After the build processes is completed, these tests can be run with ./test_fft.

## Note on Exercise 4

While we have implemented solvers for both the homogeneous and sinsusoidal heat source condition, our results for the latter are off by a scaling factor. Specifically, while the temperature field after optimisation indeed follows the same trend as the given equilibrium sinusoidal, the magnitude is off by a constant scaling factor. We hypothesize that this is because FFTW does not normalize the DFT-IDFT transformation. However, we are unsure of where to implement the scaling factor. Finally, we note again that the final temperature field indeed follows a sinusoidal trend which is independent of y and a sinusoidal function of x as expected.

And we can also clearly see for the case of initial homogeneous temperature with no heat flux that our temperature field do not change and remain homogeneous throughout the simulation, which is physically what we expect.

## Exercise 6

In order to visualize the simulation results in Paraview, we need to output the particle data, which is the temperature in our case, into a format that Paraview can read. This can be VTK format or CSV. VTK is a better option for scientific visualization since it can store more attributes.

We can include the functionality in the code to dump the temperature of each particle/grid point into a VTK-compatible format at each timestep. This can be done by implement a function that writes the simulation's particle temperature data to VTK XML Structured Grid files. The temperature for each particle is stored as a scalar value in the grid, where the grid dimensions matches the particle grid which is specified as 512x512. In our simulation, we periodically call the VTK writing function to generate files with updated temperature data for every specified time step, for instance specified by nsteps / freq. Then we can execute the simulation with the appropriate arguments such as “ 1000 10 input.csv material_point 0.01” which will generate VTK files at the specified frequency. Finally, we can open/load the VTK files in Paraview to visualize the temperature distribution over time.

