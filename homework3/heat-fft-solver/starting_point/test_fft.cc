#include "fft.hh"
#include "my_types.hh"
#include <gtest/gtest.h>
#include <fstream>
#include <sstream>
#include <iostream>

/*****************************************************************/
// Test for the forward FFT transform
/*****************************************************************/


//The checking in these tests are handled by the ASSERT_NEAR statements, which are part of the Google Test framework. 
//Instead of explicitly using if or else statements, these assertions are designed to validate conditions and automatically handle success or failure.

TEST(FFT, transform) {
  UInt N = 512;
  Matrix<complex> m(N);

  Real k = 2 * M_PI / N;
  for (auto&& entry : index(m)) {
    int i = std::get<0>(entry);
    int j = std::get<1>(entry);
    auto& val = std::get<2>(entry);
    val = cos(k * i);
  }

  Matrix<complex> res = FFT::transform(m);

  for (auto&& entry : index(res)) {
    int i = std::get<0>(entry);
    int j = std::get<1>(entry);
    auto& val = std::get<2>(entry);
    if (std::abs(val) > 1e-10)
      std::cout << i << "," << j << " = " << val << std::endl;

    
    if (i == 1 && j == 0)
      ASSERT_NEAR(std::abs(val), (N * N) / 2, 1e-6);
    else if (i == N - 1 && j == 0)
      ASSERT_NEAR(std::abs(val), (N * N) / 2, 1e-6);
    else
      ASSERT_NEAR(std::abs(val), 0, 1e-6);
  }
}
/*****************************************************************/


/*****************************************************************/
// Test for the inverse FFT transform. The idea is based on the fact that if you take first the fourrier transform of a function and then take inverse fourrier of the result, you should recover the original function.
TEST(FFT, inverse_transform) {
  UInt N = 128;  // Smaller size for quick validation
  Matrix<complex> m(N);  // Create a square matrix of size N

  // Filling the matrix with a simple cosine function
  Real k = 2 * M_PI / N;
  for (auto&& entry : index(m)) {
    int i = std::get<0>(entry);
    auto& val = std::get<2>(entry);
    val = cos(k * i);  // Assign cosine values
  }

  // Performing forward and inverse FFT
  Matrix<complex> transformed = FFT::transform(m);
  Matrix<complex> result = FFT::itransform(transformed);

  // Validating that the original matrix is reconstructed
  for (auto&& entry : index(result)) {
    int i = std::get<0>(entry);
    int j = std::get<1>(entry);
    auto& val = std::get<2>(entry);

    // Ensuring the reconstructed values match the original
    ASSERT_NEAR(std::real(val), std::real(m(i, j)), 1e-10);
    ASSERT_NEAR(std::imag(val), std::imag(m(i, j)), 1e-10);  
  }
}

/*****************************************************************/



// Implementing the test for frequencies. The python output of frequencies are computed from a separate python script called "generate_reference_frequencies.py"

TEST(FFT, computeFrequencies) {
    int N = 8; // Example size for the test
    Matrix<complex> frequencies = FFT::computeFrequencies(N);

    // Open the reference file generated by Python
    std::ifstream reference_file("../frequencies_reference.txt");
    ASSERT_TRUE(reference_file.is_open()) << "Failed to open reference file.";

    // Validate frequencies
    int i = 0, j = 0;
    double ref_freq_x, ref_freq_y;  // Variables to hold the x(real) and y(imaginary) components of the reference frequency(the two-dimensional grid of frequencies) read from the file.
    
    std::string line;

    while (std::getline(reference_file, line)) { // Iterating through Reference Frequencies
        std::stringstream ss(line);   
        char comma; // For parsing the comma
        ss >> ref_freq_x >> comma >> ref_freq_y;

        // Validating Frequencies

        ASSERT_NEAR(std::real(frequencies(i, j)), ref_freq_x, 1e-10);
        ASSERT_NEAR(std::imag(frequencies(i, j)), ref_freq_y, 1e-10);

        // Move to the next element
        j++;
        if (j == N) {
            j = 0;
            i++;
        }
    }

    reference_file.close();
    std::cout << "Frequencies match the numpy.fft.fftfreq routine." << std::endl;
}
